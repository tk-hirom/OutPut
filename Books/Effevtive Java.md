# 書いた意図
復習して暗記したい。その結果開発時や設計時に引き出せるようにしておきたい

# 2章 オブジェクトの生成と消滅
## 項目1 コンストラクタの代わりにstaticファクトリーメソッドを検討する
通常 コンストラクタ使う
↓
TIPs staticファクトリメソッドを使用する（直接コンストラクタを呼ばせない）
**注意** デザパタのファクトリメソッドとは異なる

Flyweightパターンと似ている

## メリット
1. 名前を持たせることができる
= どんなインスタンスが返ってくるかがわかる
2. コンストラクタと違い、呼び出されるたびに新しいインスタンスを返す必要がない
immutable classの場合、既存のインスタンスを使い回せる
オブジェクトが生成された時にキャッシュしておくことができる 
=> 不必要に重複したオブジェクトを作らなくていい（メモリの節約ができる）
3. 戻り値の型のサブクラスを返すことができる
= 返り値をinterfaceにすることで、実装クラスを隠蔽できる
4. 返されるオブジェクトのクラスは、入力パラメータの値に応じて呼び出しを変えることができる
= パラメータによって、返すサブクラスを変更できる。隠蔽されているから、容易に返すパターンを増減できる(3,4似た感じ)
5. 返されるオブジェクトのクラスは、そのstaticを含むクラスが書かれた時点で存在しなくよくなる

## デメリット?
### 継承してサブクラス作れなくなる（デメリットというよりは、制約）
#### 制約
publicやprotectedのコンストラクタを持たないクラスは、外部からサブクラス化（継承して新しいクラスを作ること）ができません。←そうなんだね
例えば、Javaのコレクションフレームワーク内のユーティリティクラス（CollectionsのunmodifiableListなどが返す不変リストなど）は、これに該当します。
これらのクラスは、staticファクトリメソッドを通じてのみインスタンス化でき、直接継承して拡張することは意図的に制限されています。
#### 制約がもたらす利点
コンポジションの促進: この制約は、プログラマがクラスの継承ではなく、**コンポジション（別のクラスのインスタンスを自クラスのインスタンス変数として持ち、その機能を利用すること)** を選択することを促します。コンポジションは、継承の複雑さや制限を避け、より柔軟かつ再利用しやすい設計を実現します。
不変型のサポート: 不変オブジェクト（作成後にその状態が変化しないオブジェクト）は、安全性やシンプルさ、並行処理における問題の回避などの点で優れています。staticファクトリメソッドのみを提供することで、不変性を維持するための制御が容易になります。これは、オブジェクトの作成方法を厳格に制御し、不変契約を破るようなサブクラスの作成を防ぐためです。
#### 結論
このアプローチにより、プログラマはより慎重にクラスの設計を考え、継承よりもコンポジションを選ぶことが促されます。これは、より安全で再利用しやすい、そして変更に強いソフトウェアの設計へと導くものです。また、不変型の作成と利用を容易にし、多くのプログラミング上の問題を回避するのに役立ちます。

### 探しにくい
コンストラクタと違い、staticファクトリメソッドは、どのクラスに属しているかがわかりにくい

## 項目2 多くのコンストラクタパラメータに直面したときにはビルダーを検討する
### テレスコーピング・コンストラクタ
オブジェクトの作成時に多数のコンストラクタを用意し、それぞれ異なる引数を取ることで、オーバーロードされたコンストラクタを利用してオブジェクトを初期化する方法です。
これにより、同じクラスのインスタンスを異なる状態や構成で作成することが可能になります。

テレスコーピング・コンストラクタ・パターンの主な問題点は、引数の数が増えるにつれて、コンストラクタの管理が難しくなり、コードの可読性が低下することです。

### JavaBeansパターン
パラメーターなしでコンストラクタを呼び出し、オブジェクトを作ってから、setterメソッドで値を設定する方法です。
コンストラクタの引数が多い場合には有効
不変性を担保できないこと。生成途中に不整合な状態になりうる(実行してみるまでバグがあるかどうかわからない)

### ビルダーパターン(これが良い)
必須パラメータを全て持つコンストラクタを読んで、ビルダーオブジェクトを作る

セッター呼ぶ

終わったら、パラメーターなしのbuildメソッドを読んで不変にする

ビルダークラスは、生成するクラスのstaticのメンバークラスで定義されがち

ビルダーのメソッドは自信を返すから連鎖させられる

ビルダー作成のコストが目立つ場合もある

## 項目3 privateのコンストラクタかenum型でシングルトン特性を強制する
インターフェースがないと、モック実装に置換できずテストが困難
### 実装方法
共通: constructorをprivateにする

**1. finalつけたstaticフィールドにインスタンスを返させる**
```java
// public finalのフィールドによるシングルトン  
public class Elvis {  
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() {...}  
    
    public void leaveTheBuilding() {...}  } 
```
メリット
明確性：public staticフィールドがfinalであることから、そのクラスがシングルトンであることがAPIを通じて明確になります。
つまり、誰もがそのフィールドを見るだけで、常に同じインスタンスが返されることを理解できます。

シンプルさ：実装が非常にシンプルで、初期化時に静的フィールドにインスタンスを割り当てるだけです。

**2. staticファクトリメソッドを使う**
```java
// staticファクトリメソッドによるシングルトン  
public class Elvis {  
    private static final Elvis INSTANCE = new Elvis();  
    private Elvis() {...}  
    public static Elvis getInstance() { return INSTANCE; }  
    public void leaveTheBuilding() {...}  } 

```
メリット
柔軟性：将来的にシングルトンではなくなる可能性がある場合でも、APIを変更せずに実装を変更できる点です。
例えば、ファクトリメソッドが異なるインスタンスを返すように変更することが可能です。
```java
// インスタンスの生成をスレッドごとに異なるものにする場合です。
public class Singleton {
    private static final ThreadLocal<Singleton> threadInstance = ThreadLocal.withInitial(Singleton::new);

    private Singleton() {}

    public static Singleton getInstance() { // ユーザーはこのメソッド呼び出すだけで良いから、実装を変えても影響が少ない
        return threadInstance.get();
    }
}

```

ジェネリックシングルトンファクトリ：ジェネリックを用いたシングルトンのファクトリを作成できるため、より柔軟なシングルトン実装が可能になります。
型ごとに、個別のファクトリクラスを作る必要がなくなるため、コードの重複を減らすことができます。
```java
public class GenericSingletonFactory<T> {
    private final T instance;

    private GenericSingletonFactory(T instance) {
        this.instance = instance;
    }

    public static <T> GenericSingletonFactory<T> createInstance(T instance) {
        return new GenericSingletonFactory<>(instance);
    }

    public T getInstance() {
        return instance;
    }
}

```
メソッド参照の利用：シングルトンのインスタンス取得メソッドを、Java 8のメソッド参照として使用できるため、他のAPIやラムダ式と組み合わせて使いやすくなります。

メソッド参照とは、Java 8で導入された機能で、メソッドを一つの引数として直接渡すことができるラムダ式のシンタックスシュガーです。
これにより、メソッドの呼び出しをより簡潔に記述できます。
あと、遅延評価もできる
```java
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();

    private Elvis() {}

    public static Elvis getInstance() {
        return INSTANCE;
    }

    public void leaveTheBuilding() {
        System.out.println("Elvis has left the building");
    }
}

public class Main {
    public static void main(String[] args) {
        // Elvis::getInstanceをSupplier<Elvis>として使用
        Supplier<Elvis> elvisSupplier = Elvis::getInstance;

        // SupplierからElvisインスタンスを取得してメソッドを呼び出す
        elvisSupplier.get().leaveTheBuilding();
    }
}
```
> 前述の二つの方法のどちらかを使って実装されているシングルトンのクラスをシリアライズ可能（第  12 章） にするには、 クラスの宣言に単に implements Serializable を追加するだけでは十分ではあ  りません。 シングルトンを保証し続けるには、 すべてのインスタンスフィールドを transient と宣言  して、 readResolve メソッド （項目 89） を提供しなければなりません。 そうでなければ、 シリアラ  イズされたインスタンスをディシリアライズするごとに、 新たなインスタンスが生成されてしまいま  す。 その結果、先ほどの例では、 偽者の Elvis が現れます。 これを防ぐためには、 Elvis クラスに次  の readResolve メソッドを追加します。  // シングルトン特性を保持するためのreadResolveメソッド  private Object readResolve() {  // 本物のElvisを返して、 Elvisの偽者をガベージコレクタに  // 始末させる。  return INSTANCE;  }  シングルトンを実装するための
この辺りの内容よくわからない。でも上記二つの方法は望ましくない

シングルトンパターンを実装したクラスがシリアライズ可能である場合、デシリアライズ時に新しいインスタンスが作成される可能性がある

**3.単一要素を持つenumを宣言する**
```java
// enumシングルトン - 好ましい方法  
public enum Elvis {  INSTANCE;  public void leaveTheBuilding() {...}  } 
```

簡潔でこれだけで、シリアライズの機構を提供してくれる
変なことして複数作ることもできない

## 項目4 privateのコンストラクタでインスタンス化不可能を強制する
インスタンスを必要としないユーティリティクラスなどは、コンストラクタをprivateにしてインスタンス化不可能にする
```java 
public class UtilityClass {  
    // インスタンス化不可能なクラスのためのコンストラクタ  
    private UtilityClass() {  
        throw new AssertionError();  }  
    ...  } 
```

## 項目5 資源を直接結びつけるよりも依存性注入を選ぶ
下層の資源（他クラスということか？）に依存している場合、静的型付言語なユーティリティクラス(項目4)や、シングルトン(項目3)を使うと、テストが難しくなる
それだけでなく、依存先のクラスを変更することで振る舞いを変更しにくくなる。

そこで、依存性注入を使う
```java
