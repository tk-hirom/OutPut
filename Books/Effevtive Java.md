# 書いた意図
復習して暗記したい。その結果開発時や設計時に引き出せるようにしておきたい

# 2章 オブジェクトの生成と消滅
## 項目1 コンストラクタの代わりにstaticファクトリーメソッドを検討する
通常 コンストラクタ使う
↓
TIPs staticファクトリメソッドを使用する（直接コンストラクタを呼ばせない）
**注意** デザパタのファクトリメソッドとは異なる

Flyweightパターンと似ている

## メリット
1. 名前を持たせることができる
= どんなインスタンスが返ってくるかがわかる
2. コンストラクタと違い、呼び出されるたびに新しいインスタンスを返す必要がない
immutable classの場合、既存のインスタンスを使い回せる
オブジェクトが生成された時にキャッシュしておくことができる 
=> 不必要に重複したオブジェクトを作らなくていい（メモリの節約ができる）
3. 戻り値の型のサブクラスを返すことができる
= 返り値をinterfaceにすることで、実装クラスを隠蔽できる
4. 返されるオブジェクトのクラスは、入力パラメータの値に応じて呼び出しを変えることができる
= パラメータによって、返すサブクラスを変更できる。隠蔽されているから、容易に返すパターンを増減できる(3,4似た感じ)
5. 返されるオブジェクトのクラスは、そのstaticを含むクラスが書かれた時点で存在しなくよくなる

## デメリット?
### 継承してサブクラス作れなくなる（デメリットというよりは、制約）
#### 制約
publicやprotectedのコンストラクタを持たないクラスは、外部からサブクラス化（継承して新しいクラスを作ること）ができません。←そうなんだね
例えば、Javaのコレクションフレームワーク内のユーティリティクラス（CollectionsのunmodifiableListなどが返す不変リストなど）は、これに該当します。
これらのクラスは、staticファクトリメソッドを通じてのみインスタンス化でき、直接継承して拡張することは意図的に制限されています。
#### 制約がもたらす利点
コンポジションの促進: この制約は、プログラマがクラスの継承ではなく、**コンポジション（別のクラスのインスタンスを自クラスのインスタンス変数として持ち、その機能を利用すること)** を選択することを促します。コンポジションは、継承の複雑さや制限を避け、より柔軟かつ再利用しやすい設計を実現します。
不変型のサポート: 不変オブジェクト（作成後にその状態が変化しないオブジェクト）は、安全性やシンプルさ、並行処理における問題の回避などの点で優れています。staticファクトリメソッドのみを提供することで、不変性を維持するための制御が容易になります。これは、オブジェクトの作成方法を厳格に制御し、不変契約を破るようなサブクラスの作成を防ぐためです。
#### 結論
このアプローチにより、プログラマはより慎重にクラスの設計を考え、継承よりもコンポジションを選ぶことが促されます。これは、より安全で再利用しやすい、そして変更に強いソフトウェアの設計へと導くものです。また、不変型の作成と利用を容易にし、多くのプログラミング上の問題を回避するのに役立ちます。

### 探しにくい
コンストラクタと違い、staticファクトリメソッドは、どのクラスに属しているかがわかりにくい

## 項目2 多くのコンストラクタパラメータに直面したときにはビルダーを検討する
### テレスコーピング・コンストラクタ
オブジェクトの作成時に多数のコンストラクタを用意し、それぞれ異なる引数を取ることで、オーバーロードされたコンストラクタを利用してオブジェクトを初期化する方法です。
これにより、同じクラスのインスタンスを異なる状態や構成で作成することが可能になります。

テレスコーピング・コンストラクタ・パターンの主な問題点は、引数の数が増えるにつれて、コンストラクタの管理が難しくなり、コードの可読性が低下することです。

### JavaBeansパターン
パラメーターなしでコンストラクタを呼び出し、オブジェクトを作ってから、setterメソッドで値を設定する方法です。
コンストラクタの引数が多い場合には有効
不変性を担保できないこと。生成途中に不整合な状態になりうる(実行してみるまでバグがあるかどうかわからない)

### ビルダーパターン(これが良い)
必須パラメータを全て持つコンストラクタを読んで、ビルダーオブジェクトを作る

セッター呼ぶ

終わったら、パラメーターなしのbuildメソッドを読んで不変にする

ビルダークラスは、生成するクラスのstaticのメンバークラスで定義されがち

ビルダーのメソッドは自信を返すから連鎖させられる

ビルダー作成のコストが目立つ場合もある

## 項目3 privateのコンストラクタかenum型でシングルトン特性を強制する
インターフェースがないと、モック実装に置換できずテストが困難
### 実装方法
共通: constructorをprivateにする

**1. finalつけたstaticフィールドにインスタンスを返させる**
```java
// public finalのフィールドによるシングルトン  
public class Elvis {  
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() {...}  
    
    public void leaveTheBuilding() {...}  } 
```
メリット
明確性：public staticフィールドがfinalであることから、そのクラスがシングルトンであることがAPIを通じて明確になります。
つまり、誰もがそのフィールドを見るだけで、常に同じインスタンスが返されることを理解できます。

シンプルさ：実装が非常にシンプルで、初期化時に静的フィールドにインスタンスを割り当てるだけです。

**2. staticファクトリメソッドを使う**
```java
// staticファクトリメソッドによるシングルトン  
public class Elvis {  
    private static final Elvis INSTANCE = new Elvis();  
    private Elvis() {...}  
    public static Elvis getInstance() { return INSTANCE; }  
    public void leaveTheBuilding() {...}  } 

```
メリット
柔軟性：将来的にシングルトンではなくなる可能性がある場合でも、APIを変更せずに実装を変更できる点です。
例えば、ファクトリメソッドが異なるインスタンスを返すように変更することが可能です。
```java
// インスタンスの生成をスレッドごとに異なるものにする場合です。
public class Singleton {
    private static final ThreadLocal<Singleton> threadInstance = ThreadLocal.withInitial(Singleton::new);

    private Singleton() {}

    public static Singleton getInstance() { // ユーザーはこのメソッド呼び出すだけで良いから、実装を変えても影響が少ない
        return threadInstance.get();
    }
}

```

ジェネリックシングルトンファクトリ：ジェネリックを用いたシングルトンのファクトリを作成できるため、より柔軟なシングルトン実装が可能になります。
型ごとに、個別のファクトリクラスを作る必要がなくなるため、コードの重複を減らすことができます。
```java
public class GenericSingletonFactory<T> {
    private final T instance;

    private GenericSingletonFactory(T instance) {
        this.instance = instance;
    }

    public static <T> GenericSingletonFactory<T> createInstance(T instance) {
        return new GenericSingletonFactory<>(instance);
    }

    public T getInstance() {
        return instance;
    }
}

```
メソッド参照の利用：シングルトンのインスタンス取得メソッドを、Java 8のメソッド参照として使用できるため、他のAPIやラムダ式と組み合わせて使いやすくなります。

メソッド参照とは、Java 8で導入された機能で、メソッドを一つの引数として直接渡すことができるラムダ式のシンタックスシュガーです。
これにより、メソッドの呼び出しをより簡潔に記述できます。
あと、遅延評価もできる
```java
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();

    private Elvis() {}

    public static Elvis getInstance() {
        return INSTANCE;
    }

    public void leaveTheBuilding() {
        System.out.println("Elvis has left the building");
    }
}

public class Main {
    public static void main(String[] args) {
        // Elvis::getInstanceをSupplier<Elvis>として使用
        Supplier<Elvis> elvisSupplier = Elvis::getInstance;

        // SupplierからElvisインスタンスを取得してメソッドを呼び出す
        elvisSupplier.get().leaveTheBuilding();
    }
}
```
> 前述の二つの方法のどちらかを使って実装されているシングルトンのクラスをシリアライズ可能（第  12 章） にするには、 クラスの宣言に単に implements Serializable を追加するだけでは十分ではあ  りません。 シングルトンを保証し続けるには、 すべてのインスタンスフィールドを transient と宣言  して、 readResolve メソッド （項目 89） を提供しなければなりません。 そうでなければ、 シリアラ  イズされたインスタンスをディシリアライズするごとに、 新たなインスタンスが生成されてしまいま  す。 その結果、先ほどの例では、 偽者の Elvis が現れます。 これを防ぐためには、 Elvis クラスに次  の readResolve メソッドを追加します。  // シングルトン特性を保持するためのreadResolveメソッド  private Object readResolve() {  // 本物のElvisを返して、 Elvisの偽者をガベージコレクタに  // 始末させる。  return INSTANCE;  }  シングルトンを実装するための
この辺りの内容よくわからない。でも上記二つの方法は望ましくない

シングルトンパターンを実装したクラスがシリアライズ可能である場合、デシリアライズ時に新しいインスタンスが作成される可能性がある

**3.単一要素を持つenumを宣言する**
```java
// enumシングルトン - 好ましい方法  
public enum Elvis {  INSTANCE;  public void leaveTheBuilding() {...}  } 
```

簡潔でこれだけで、シリアライズの機構を提供してくれる
変なことして複数作ることもできない

## 項目4 privateのコンストラクタでインスタンス化不可能を強制する
インスタンスを必要としないユーティリティクラスなどは、コンストラクタをprivateにしてインスタンス化不可能にする
```java 
public class UtilityClass {  
    // インスタンス化不可能なクラスのためのコンストラクタ  
    private UtilityClass() {  
        throw new AssertionError();  }  
    ...  } 
```

## 項目5 資源を直接結びつけるよりも依存性注入を選ぶ
下層の資源（他クラスということか？）に依存している場合、静的型付言語なユーティリティクラス(項目4)や、シングルトン(項目3)を使うと、テストが難しくなる
それだけでなく、依存先のクラスを変更することで振る舞いを変更しにくくなる。

そこで、クラスの中で直接依存先のインスタンスを生成するのではなく、依存性注入を使う

## 項目6 不必要なオブジェクトの生成を避ける
staticファクトリメソッドを使うと解決できる

遅延初期化という手段もあるが、改善はあまり見込めない上に煩雑になる

アダプタの例はよくわからなかったが、使い回しできるよってことでいいのかな？

### 自動ボクシング

**自動ボクシング**という方法でも不要なオブジェクトが生成されることがある

**ボクシング（Boxing）**
ボクシングは、プリミティブ型の値を対応するラッパークラスのインスタンスに変換するプロセスを指します。

これにより、プリミティブ型の値をオブジェクトとして扱うことができます。

例えば、int型の値をIntegerオブジェクトに変換することがボクシングの一例です。
```java
int i = 10;
Integer boxed = Integer.valueOf(i); // ボクシング

```

**自動ボクシング**
Java 5以降、自動ボクシングという機能が導入されました。

これは、プリミティブ型とラッパークラスの間での変換をコンパイラが自動的に行う機能です。

つまり、明示的にラッパークラスのvalueOfメソッドを呼び出す必要がなく、代入やメソッドの引数としてプリミティブ型の値を使用するだけで、適切なラッパークラスのオブジェクトに自動的に変換されます。

```java
Integer boxed = 10; // 自動ボクシング
```

逆のアンボクシングも自動で行ってくれる

例えば、下記のようなコードは遅い。これはsum変数がLong(ラッパークラス)で宣言されているためです
```java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    return sum;
}
```
変数sum  は、 long ではなく Long と宣言されています。 
その結果、 プログラムは約2**31個の不必要な Longインスタンスを生成します （大ざっぱに言って long i を Long sum に加算するごとに一つ）。
sum の宣言  を Long から long に変更することで、 私のマシンでは実行時間が 6.3秒から 0.59秒に短縮されます。

### まとめ
無闇にオブジェクト生成を避けろというのではない

必要な時は使うべきだし、むしろ自分でオブジェクトプールを管理するのはよくない

必要な場面では、オブジェクトのコピーもすべき（後述）

**オブジェクトプール**
デザパタの一種。生成に時間がかかるオブジェクトを保持しておいて、必要に応じて貸し出すもの。

自分でそんなことしても、メモリ不足やメモリリークの原因になるし、コードが複雑になる

## 項目7 使われなくなったオブジェクト参照を取り除く
ガベージコレクションを持つ言語でも、メモリ管理ついては考えなくてはならない

**メモリリーク**
メモリリークとは、プログラムが使用しているメモリが解放されずに残ってしまうことを指します。

メモリリークが発生すると、プログラムが使用しているメモリが増加し続け、最終的にはメモリ不足に陥る可能性があります。

スタックが大きくなってそのあと小さくなると、スタックから取り出されたオブジェクトは参照されなくなるが、ガベージコレクションされない

下記のコードだと、スタックにいくつかのオブジェクトをプッシュし、その後でそれらをポップするという操作を行った場合、ポップされたオブジェクトの参照はスタック内部の配列に残り続けます。

例えば、スタックにオブジェクトA、B、Cをプッシュし、その後にポップを2回実行してBとCを取り出したとします。

この時、配列elements内のBとCへの参照は依然として残っているため、これらのオブジェクトはガベージコレクタによって回収されません。
```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        return elements[--size];
    }

    /**
     * スタックが拡張される必要がある場合、その容量を2倍に拡張します。
     */
    private void ensureCapacity() {
        if (elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }
}
```

正しくは、下記のように使われなくなる参照をnullにする
```java
public Object pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null; // 参照を外す
    return result;
}
```

メモリリークは
1. クラスが独自のメモリを管理しているとき、注意が必要
2. キャッシュに
3. リスナー、コールバック
弱い参照だけ保存するようにすることで、ガベージコレクトされるようになる

## 項目8　finalizerとcleanerを避ける TODO 後回し
**finalizer**

一般には不要。Java9から非推奨

**Cleaner**

finalizerの代替手段。Java9から導入された

一般には必要ないのは、同じ

## 項目9 try-finallyよりもtry-with-resourcesを使う TODO 後回し

# 3章 全てのオブジェクトに共通のメソッド

オーバーライドの話なら不要 TODO 後回し

# 4章 クラスとインタフェース
## 項目15 クラスとメンバーへのアクセス可能性を最小限にする

